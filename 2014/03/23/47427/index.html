<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Objective-C," />





  <link rel="alternate" href="/atom.xml" title="逆水行舟" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="简介预备知识 具备 C 类似编程语言的经验，对于不具备语言基础的，可以先阅读 Dava Mark 写的《Learn C On the Mac》。  历史背景 20世纪80年代早期，Brad Cox 结合 C 语言及 Smalltakl 语言形成了 Objective-C。  内容简介Objective-C 是 C 语言的一个扩展集。Objective-C 以 C 语言为基础，扩展了许多特性。">
<meta name="keywords" content="Objective-C">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C 学习">
<meta property="og:url" content="http://blog.longgen.me/2014/03/23/47427/index.html">
<meta property="og:site_name" content="逆水行舟">
<meta property="og:description" content="简介预备知识 具备 C 类似编程语言的经验，对于不具备语言基础的，可以先阅读 Dava Mark 写的《Learn C On the Mac》。  历史背景 20世纪80年代早期，Brad Cox 结合 C 语言及 Smalltakl 语言形成了 Objective-C。  内容简介Objective-C 是 C 语言的一个扩展集。Objective-C 以 C 语言为基础，扩展了许多特性。">
<meta property="og:updated_time" content="2017-05-28T14:31:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C 学习">
<meta name="twitter:description" content="简介预备知识 具备 C 类似编程语言的经验，对于不具备语言基础的，可以先阅读 Dava Mark 写的《Learn C On the Mac》。  历史背景 20世纪80年代早期，Brad Cox 结合 C 语言及 Smalltakl 语言形成了 Objective-C。  内容简介Objective-C 是 C 语言的一个扩展集。Objective-C 以 C 语言为基础，扩展了许多特性。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '3S75IDBWI0',
      apiKey: 'a988f815a9f762629bb4c1c06c948df9',
      indexName: 'blog_hexo_search_index',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.longgen.me/2014/03/23/47427/"/>





  <title>Objective-C 学习 | 逆水行舟</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e27df63661dd7d99e7c473280f19e32e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逆水行舟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Whatever is worth doing is worth doing well.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.longgen.me/2014/03/23/47427/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arcticfox">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/fox.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逆水行舟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Objective-C 学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-03-23T17:01:01+08:00">
                2014-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2014/03/23/47427/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2014/03/23/47427/" class="leancloud_visitors" data-flag-title="Objective-C 学习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>具备 C 类似编程语言的经验，对于不具备语言基础的，可以先阅读 Dava Mark 写的《Learn C On the Mac》。</li>
</ul>
<h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><ul>
<li>20世纪80年代早期，Brad Cox 结合 C 语言及 Smalltakl 语言形成了 Objective-C。</li>
</ul>
<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>Objective-C 是 C 语言的一个扩展集。Objective-C 以 C 语言为基础，扩展了许多特性。</p>
<a id="more"></a>
<h1 id="对-C-的扩展"><a href="#对-C-的扩展" class="headerlink" title="对 C 的扩展"></a>对 C 的扩展</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ul>
<li><p>安装 Xcode</p>
</li>
<li><p>编写代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main (int argc, const char *argv[])</div><div class="line">&#123;</div><div class="line">    NSlog(@&quot;Hello, world!&quot;);</div><div class="line"></div><div class="line">    return (0);</div><div class="line">&#125;   // main</div></pre></td></tr></table></figure>
<ul>
<li>.m 扩展名表示 Objective-C 文件，应由 Objective-C 编译器处理；.c 由 C编译器处理；.cpp 由 C++ 编译器处理。在 Xcode 中，所有这些编译工作全由 GCC（GNU Compiler Collection，GNU编译器集合）处理，这个编译器能理解 C 语言的这三个变体</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h3><p>C 语言中使用 #include 语句通知编译器在头文件中查询定义；Objective-C 中也可以使用 #include 来实现这个目的，但一般只使用 #import。#import 保证头文件只被包含一次</p>
<blockquote>
<p>C 语言中，长用基于 #ifdef 命令的方案来避免一个文件包含另一个文件，而后者又包含第一个文件的情况；Objective-C 中，使用 #import 可以实现这个功能。</p>
</blockquote>
<p>框架是一种聚集在一个单元的部件集合，包含头文件、库、图像、声音文件等。苹果公司提供 Cocoa（Cocoa 包含 Foundation 和 Application Kit（也称为 AppKit））、Carbon、QuickTime、OpenGL 等技术框架。还有一个支持框架的套件，包含 Core Animation 和 Core Image。</p>
<ul>
<li>Foundation 框架包含的头文件 Headers 目录位置：/System/Library/Frameworks/Foundation.framework/Headers/ 。仅查看，不修改或删除以避免造成破坏。</li>
</ul>
<blockquote>
<p>学完本书后，还需要精通 Cocoa 和 Application Kit，用户界面元素、打印、声音、颜色和声音管理、AppleScript 支持等。参阅《Learn Cocoa on the Mac》。</p>
</blockquote>
<h3 id="NSLog-和-“字符串”"><a href="#NSLog-和-“字符串”" class="headerlink" title="NSLog() 和 @“字符串”"></a>NSLog() 和 @“字符串”</h3><ul>
<li><p>类似 C 语言的 printf()，相对添加了新特性，例如时间戳、日期戳和自动附加换行符（’\n’）等。</p>
</li>
<li><p>NS 前缀代表函数来自Cocoa（前身NextSTEP）。</p>
</li>
<li><p>双引号字符串前加 @ 符号，表示引用的字符串应该作为 Cocoa 的 NSString 元素来处理</p>
</li>
</ul>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>类型 BOOL，值 YES 或 NO。</p>
<blockquote>
<p>Objective-C 中的 BOOL 实际上是一种对带符号的字符类型（signed char）的定义（typedef），它使用8位存储空间。YES 定义为1，NO 定义为0（使用 #define）。Objective-C 并不将 BOOL 作为仅能保存 YES 或 NO 值得真正布尔类型来处理。编译器将 BOOL 认作8位二进制数，YES 和 NO 只是一种约定。这引发了一个小问题：如果不小心将一个长于1字节的整型值（例如 short 或 int 值）赋给一个 BOOL 变量，那么只有低位字节会用作 BOOL 值。假设该低位字节刚好为0（例如8960，写成十六进制为0x2300），BOOL 值将会是0，即 NO 值。</p>
</blockquote>
<h1 id="面向对象编程基础知识"><a href="#面向对象编程基础知识" class="headerlink" title="面向对象编程基础知识"></a>面向对象编程基础知识</h1><p>面向对象编程（Object-Oriented Programming，OOP）。Cocoa 基于 OOP 概念，Objective-C 是一种面向对象语言</p>
<h2 id="间接（indirection）"><a href="#间接（indirection）" class="headerlink" title="间接（indirection）"></a>间接（indirection）</h2><h3 id="变量与间接"><a href="#变量与间接" class="headerlink" title="变量与间接"></a>变量与间接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[])</div><div class="line">&#123;</div><div class="line">    int count = 5;</div><div class="line"></div><div class="line">    NSLog(@&quot;The numbers from 1 to %d:&quot;, count);</div><div class="line"></div><div class="line">    int i;</div><div class="line"></div><div class="line">    for (i = 1; i &lt;= count; i++) &#123;</div><div class="line">        NSLog(@&quot;%d\n&quot;, i);</div><div class="line">    &#125;</div><div class="line">    return (0);</div><div class="line">&#125;   // main</div></pre></td></tr></table></figure>
<h3 id="使用文件名的间接"><a href="#使用文件名的间接" class="headerlink" title="使用文件名的间接"></a>使用文件名的间接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[])</div><div class="line">&#123;</div><div class="line">    if (argc == 1) &#123;</div><div class="line">        NSLog(@&quot;You need to provide a file name!&quot;);</div><div class="line">        return (1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FILE *wordFile = fopen(argv[1], &quot;r&quot;);</div><div class="line">    char word[100];</div><div class="line"></div><div class="line">    while (fgets(word, 100, wordFile)) &#123;</div><div class="line">        // strip off the trailing \n</div><div class="line">        word[strlen[word] - 1] = &apos;\0&apos;;</div><div class="line"></div><div class="line">        NSLog(@&quot;%s is %d characters long&quot;, word, strlen(word));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fclose(wordFile);</div><div class="line"></div><div class="line">    return (0);</div><div class="line"></div><div class="line">&#125;   // main</div></pre></td></tr></table></figure>
<blockquote>
<p>在 Xcode 中提供文件路径：在 Xcode 文件列表中展开 Executables，并双击程序名；单击 Arguments 区域下的加号，并输入启动参数。</p>
</blockquote>
<h2 id="在面向对象的编程中使用间接"><a href="#在面向对象的编程中使用间接" class="headerlink" title="在面向对象的编程中使用间接"></a>在面向对象的编程中使用间接</h2><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="为何使用继承"><a href="#为何使用继承" class="headerlink" title="为何使用继承"></a>为何使用继承</h2><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface Circle : NSObject</div></pre></td></tr></table></figure>
<blockquote>
<p>某些语言（例如 C++）具有多继承特性。但 Objective-C 不支持多继承。你可以通过 Objective-C 的其他特性获取多继承的优点，例如分类或协议</p>
</blockquote>
<h2 id="继承的工作机制"><a href="#继承的工作机制" class="headerlink" title="继承的工作机制"></a>继承的工作机制</h2><h3 id="方法调度"><a href="#方法调度" class="headerlink" title="方法调度"></a>方法调度</h3><p>对象收到消息时，它从自身开始往其继承链上的超类层层往上查找对应方法，并执行。若在最高级别的超类（NSObject）中也没有该方法，则会出现运行时错误。</p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><h2 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h2><h1 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h1><h2 id="什么是复合"><a href="#什么是复合" class="headerlink" title="什么是复合"></a>什么是复合</h2><h2 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h2><p>为存取方法命名：setter 方法需加前缀 set；getter 方法则仅仅根据其返回的属性名称来命名，不要将get作为前缀</p>
<blockquote>
<p>get 这个词在 Cocoa 中有特殊约定含义：get 出现在 Cocoa 的方法名称中，意味着这个方法会通过你当做参数传入的指针来返回数值。例如，NSData的getBytes方法。</p>
</blockquote>
<h2 id="复合（has-a）与继承（is-a）的选择"><a href="#复合（has-a）与继承（is-a）的选择" class="headerlink" title="复合（has a）与继承（is a）的选择"></a>复合（has a）与继承（is a）的选择</h2><h1 id="源文件组织"><a href="#源文件组织" class="headerlink" title="源文件组织"></a>源文件组织</h1><p>Objective-C 类的源码分为两部分：接口（interface），用来提供类的公共描述；实现（implementation），告诉编译器如何让该类工作，实现了接口中声明的方法。</p>
<ul>
<li><p>.h 文件存放接口部分代码：类的 @interface 指令、公共 struct 定义、enum 常量、#defines 和 extern 全局变量等。</p>
</li>
<li><p>.m 文件存放所有实现细节：类的 @implementation 指令、全局变量的定义、私有struct等</p>
</li>
</ul>
<blockquote>
<p>.mm 文件表示你用 Objective-C++ 编写代码的文件，可以使用 C++ 语言和 Objective-C 结合编程</p>
<p>@class 创建向前引用，避免循环依赖关系时，编译错误</p>
</blockquote>
<h1 id="深入了解-Xcode"><a href="#深入了解-Xcode" class="headerlink" title="深入了解 Xcode"></a>深入了解 Xcode</h1><ul>
<li><p>通用常用快捷键</p>
<ul>
<li>control + A：      移动到行首（同 command + 左箭头）</li>
<li>control + E：      移动到行尾（同 command + 右箭头）</li>
<li>control + D：      删除（Delete）光标右边的字符</li>
<li>control + K：      删除（Kill）光标所在行中光标后的代码</li>
<li>control + L：      将插入点置于窗口正中。找不到光标或者想要移动窗口使插入点快速位于正中的快捷键</li>
</ul>
</li>
<li><p>Xcode 快捷键</p>
<ul>
<li>command + shift + D：          查找文件</li>
<li>command + option + 上箭头：     查看当前文件的配套文件</li>
<li>command + shift + E：          打开扩展编辑器</li>
<li>command + [：                  左移代码块</li>
<li>command + ]：                  右移代码块</li>
<li>Tab：                          接受代码提示</li>
<li>Esc：                          显示代码提示菜单</li>
<li>control + .：                  循环浏览代码提示</li>
<li>shift + control + .：          反向循环浏览代码提示</li>
<li>control + /：                  移动到代码提示中得下一个占位符</li>
<li>command + option + D：         显示 Open Quickly 窗口</li>
<li>command + option + 上箭头：     查看当前文件的配套文件</li>
<li>command + D：                  添加书签</li>
<li>option + 双击某个符号：          查找该符号相关文档</li>
<li>command + R：                  运行程序</li>
<li>command + Y：                  调试程序</li>
<li>command + option + P：         继续（在调试器中）</li>
<li>command + option + O：         跳过</li>
<li>command + option + I：         跳入</li>
<li>command + option + T：         跳出</li>
</ul>
</li>
</ul>
<blockquote>
<p>Xcode 使用的调试器是 GDB。GDB 是GNU项目的一部分，它可以在很多不同平台上使用。</p>
</blockquote>
<h1 id="Foundation-Kit"><a href="#Foundation-Kit" class="headerlink" title="Foundation Kit"></a>Foundation Kit</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="NSRange"><a href="#NSRange" class="headerlink" title="NSRange"></a>NSRange</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef struct _NSRange &#123;</div><div class="line">    unsigned int location;</div><div class="line">    unsigned int length;</div><div class="line">&#125; NSRange;</div><div class="line"></div><div class="line">/* 聚合结构赋值 */</div><div class="line">NSRange range = &#123;17, 4&#125;;</div><div class="line"></div><div class="line">/* NSMakeRange()赋值 */</div><div class="line">NSRange r = NSMakeRange(17, 4);</div></pre></td></tr></table></figure>
<h3 id="几何数据类型"><a href="#几何数据类型" class="headerlink" title="几何数据类型"></a>几何数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef struct _NSPoint &#123;</div><div class="line">    float x;</div><div class="line">    float y;</div><div class="line">&#125; NSPoint;</div><div class="line"></div><div class="line">typedef struct _NSSize &#123;</div><div class="line">    float width;</div><div class="line">    float height;</div><div class="line">&#125; NSSize;</div><div class="line"></div><div class="line">typedef struct _NSRect &#123;</div><div class="line">    NSPoint origin;</div><div class="line">    NSSize size;</div><div class="line">&#125; NSRect;</div><div class="line"></div><div class="line">/* 创建这些数据类型的快捷函数：NSMakePoint()、NSMakeSize() 和 NSMakeRect() */</div></pre></td></tr></table></figure>
<blockquote>
<p>这些数据类型是 C 的 struct，能提升性能。程序（尤其是 GUI 程序）会用到许多临时的点，大小和句型来完成它们的工作。所有的 Objective-C 对象都是动态分配的，而动态分配是一个代价较高得操作，它会消耗大量的时间。所以将这些结构创建成第一等级的对象都会在使用过程中增加大量的系统开销。</p>
</blockquote>
<h2 id="不可变字符串-NSString"><a href="#不可变字符串-NSString" class="headerlink" title="不可变字符串 NSString"></a>不可变字符串 NSString</h2><ul>
<li><p>NSString 的 length 方法能够准确无误的处理国际字符串，如含有中文、俄文或日文字符的字符串，以及使用 Unicode 国际字符标准的字符串。</p>
</li>
<li><p>比较两个字符串内容是否相等时，应用 isEuqalToString:，而不能用 == 进行比较，后者仅进行指针（即是否是同一个对象）的比较。</p>
</li>
<li><p>NSString 是不可变的。它的子类 NSMutableString 是可变字符串。</p>
</li>
</ul>
<h2 id="集合家族"><a href="#集合家族" class="headerlink" title="集合家族"></a>集合家族</h2><h3 id="不可变数组-NSArray"><a href="#不可变数组-NSArray" class="headerlink" title="不可变数组 NSArray"></a>不可变数组 NSArray</h3><p>NSArray 是一个 Cocoa 类，用来存储对象的有序列表。它只能存储 Objective-C 对象，而不能存储 C 语言中的基本数据类型，如 int、float、enum、struct，或 NSArray 中的随机指针；同时，不能在 NSArray 中存储 nil（对象的零值或 NULL 值）。</p>
<h3 id="可变数组-NSMutableArray"><a href="#可变数组-NSMutableArray" class="headerlink" title="可变数组 NSMutableArray"></a>可变数组 NSMutableArray</h3><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSArray *array;</div><div class="line">array = [NSArray arrayWithObjects: @&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];</div><div class="line">NSEnumerator *enumerator;</div><div class="line">enumerator = [array objectEnumerator];</div><div class="line"></div><div class="line">id thingie;</div><div class="line">while (thingie = [enumerator nextObject]) &#123;</div><div class="line">    NSLog(@&quot;I found %@&quot;, thingie);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 可变数组枚举时，不能添加或身处对象等方式改变数组容器，否则可能会得到未定义结果 */</div></pre></td></tr></table></figure>
<h3 id="快速枚举"><a href="#快速枚举" class="headerlink" title="快速枚举"></a>快速枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* Mac OS X 10.5（Leopard），Objective-C 2.0 版本之后，增加快速枚举 */</div><div class="line">for (NSString *string in array) &#123;</div><div class="line">    NSLog(@&quot;I found %@&quot;, string);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不可变字典-NSDictionary-与-可变字典-NSMutableDictionary"><a href="#不可变字典-NSDictionary-与-可变字典-NSMutableDictionary" class="headerlink" title="不可变字典 NSDictionary 与 可变字典 NSMutableDictionary"></a>不可变字典 NSDictionary 与 可变字典 NSMutableDictionary</h3><blockquote>
<p>字典（也被称为散列表或关联数组）使用的是键查询的优化存储方式，它可以立即找出要查询的数据，而不需要遍历整个数组，比普通数组的查询方式更为快速</p>
</blockquote>
<h3 id="使用，但不要扩展"><a href="#使用，但不要扩展" class="headerlink" title="使用，但不要扩展"></a>使用，但不要扩展</h3><p>在 Cocoa 中，许多类实际上是以 <em>类簇</em> 的方式实现的，即它们是隐藏在通用接口下的与实现相关的类。创建 NSString 对象时，实际上获得的可能是 NSLiteralString、NSCFString、NSSimpleCString、NSBallofString 或者其他未写入文档的与实现相关的对象。通常，你可以将 NSString 或 NSArray 复合到你的某个类中或者使用类别来解决这种编程问题，而不用创建子类。</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>NSArray 和 NSDictionary 只能存储对象，而不能直接存储任何基本类型的数据，如 int、float 或 struct。但你可以用对象来封装基本类型（装箱，boxing），例如，将 int 数据封装在一个对象中，然后就可以存入 NSArray 或 NSDictionary 了。</p>
<h3 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h3><blockquote>
<p>通常将一个基本类型的数据封装成对象叫做 <em>装箱（boxing）</em>，从对象中提取基本类型的数据叫做 <em>取消装箱（unboxing）</em>。有些语言有 <em>自动装箱</em> 功能。Objective-C 语言不支持自动装箱。</p>
</blockquote>
<h3 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h3><p>NSNumber 实际上是 NSValue 的子类，NSValue 可以包装任意值。你可以用 NSValue 将结构放入 NSArray 或 NSDictionary 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSRect rect = NSMakeRect(1, 2, 30, 40);</div><div class="line"></div><div class="line">NSValue *value;</div><div class="line">value = [NSValue valueWithBytes: &amp;rect objCType: @encode(NSRect)];</div><div class="line"></div><div class="line">[array addObject: value];</div><div class="line"></div><div class="line">value = [array objectAtIndex: 0];</div><div class="line">[value getValue: &amp;rect];</div></pre></td></tr></table></figure>
<h3 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h3><p>使用NSNull值代表不存在的意义，它可以被加入到集合中。<code>[NSNull null]</code> 总是返回一样的数值，并且可以使用 == 运算符进行比较。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Objective-C 2.0 提供了垃圾回收机制。</p>
<h2 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h2><h3 id="引用计数（reference-counting，也叫保留计数）"><a href="#引用计数（reference-counting，也叫保留计数）" class="headerlink" title="引用计数（reference counting，也叫保留计数）"></a>引用计数（reference counting，也叫保留计数）</h3><h3 id="对象所有权（object-ownership）"><a href="#对象所有权（object-ownership）" class="headerlink" title="对象所有权（object ownership）"></a>对象所有权（object ownership）</h3><h3 id="访问方法中的保留和释放"><a href="#访问方法中的保留和释放" class="headerlink" title="访问方法中的保留和释放"></a>访问方法中的保留和释放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void) setEnging: (Engine *) newEngine</div><div class="line">&#123;</div><div class="line">    [newEngine retain];</div><div class="line">    [engine release];</div><div class="line">    engine = newEngine;</div><div class="line">&#125;   // setEngine</div></pre></td></tr></table></figure>
<h2 id="自动释放"><a href="#自动释放" class="headerlink" title="自动释放"></a>自动释放</h2><h3 id="所有对象全部入池"><a href="#所有对象全部入池" class="headerlink" title="所有对象全部入池"></a>所有对象全部入池</h3><p>Cocoa 中有一个 <em>自动释放池（autorelease pool）</em> 的概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (NSString *) description</div><div class="line">&#123;</div><div class="line">    NSString *description;</div><div class="line">    description = [[NSString alloc] initWithFormat: @&quot;I am %d years old.&quot;, 4];</div><div class="line"></div><div class="line">    return ([description autorelease]);</div><div class="line">&#125;   // description</div><div class="line"></div><div class="line">// 你可以编写如下代码</div><div class="line">NSLog(@&quot;%@&quot;, [someObject description]);</div></pre></td></tr></table></figure>
<h3 id="自动释放池的销毁时间"><a href="#自动释放池的销毁时间" class="headerlink" title="自动释放池的销毁时间"></a>自动释放池的销毁时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 创建池</div><div class="line">NSAutoreleasePool *pool;</div><div class="line">pool = [[NSAutoreleasePool alloc] init];</div><div class="line">// 其他代码</div><div class="line"></div><div class="line">// 释放池</div><div class="line">[pool release];</div></pre></td></tr></table></figure>
<blockquote>
<p>-drain 方法只是清空自动释放池而不销毁它。-drain 方法适用于Mac OS X 10.4（Tiger）及更高版本。</p>
</blockquote>
<h3 id="自动释放池的工作过程"><a href="#自动释放池的工作过程" class="headerlink" title="自动释放池的工作过程"></a>自动释放池的工作过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int main (int argc, const char *argv[])</div><div class="line">&#123;</div><div class="line">    NSAutoreleasePool *pool;</div><div class="line">    pool = [[NSAutoreleasePool alloc] init];</div><div class="line"></div><div class="line">    RetainTracker *tracker;</div><div class="line">    tracker = [RetainTracker new];   // count: 1</div><div class="line"></div><div class="line">    [tracker retain]; // count: 2</div><div class="line">    [tracker autorelease]; // count: still 2</div><div class="line">    [tracker release];  // count: 1</div><div class="line"></div><div class="line">    NSLog(@&quot;releasing pool&quot;);</div><div class="line">    [pool release];</div><div class="line"></div><div class="line">    return (0);</div><div class="line">&#125;   // main</div></pre></td></tr></table></figure>
<h2 id="Cocoa-内存管理规则"><a href="#Cocoa-内存管理规则" class="headerlink" title="Cocoa 内存管理规则"></a>Cocoa 内存管理规则</h2><ul>
<li><p>当你使用 new、alloc 或 copy 方法创建一个对象时，该对象的保留计数器值为1。当不再使用该对象时，你需要负责向该对象发送一条 release 或 autorelease 消息。</p>
</li>
<li><p>当你通过任何其他方法获得一个对象时，则将设该对象的保留计数器值为1，而且已经被设置为自动释放，你不需要执行任何操作来确保该对象被清理。如果你打算在一段时间内拥有该对象，则需要保留它并确保在操作完成时释放它。</p>
</li>
<li><p>如果你保留了某个对象，你需要（最终）释放或自动释放该对象。必须保持 retain 方法和 release 方法的使用次数相等。</p>
</li>
</ul>
<h3 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h3><h3 id="拥有对象"><a href="#拥有对象" class="headerlink" title="拥有对象"></a>拥有对象</h3><p>通常，你可能希望在多个代码行中一直拥有某个对象。常见方法：在其他对象的实例变量中使用这些对象，将它们加入到诸如 NSArray 或 NSDictionary 等集合中，或者（更罕见的情况）将其作为全局变量使用。</p>
<p>如果你正在使用 new、alloc 或 copy 方法获得一个对象，则不需要执行任何其他操作。该对象的保留计数器值为1，因此它将一直保留，只是一定要在拥有该对象的对象的 dealloc 方法中释放该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void) doStuff</div><div class="line">&#123;</div><div class="line">    // flonkArray is an instance variable</div><div class="line">    flonkArray = [NSMutableArray new];    // count: 1</div><div class="line">&#125;   // doStuff</div><div class="line"></div><div class="line">- (void) dealloc</div><div class="line">&#123;</div><div class="line">    [flonkArray release];     // count: 0</div><div class="line">    [super dealloc];</div><div class="line">&#125;   // dealloc</div></pre></td></tr></table></figure>
<p>如果你使用除 alloc、new 或 copy 以外的方法获得一个对象，你需要保留该对象。考虑编写 GUI 应用程序时事件循环的情况。你希望保留自动释放的对象，使这些对象在当前的事件循环结束以后仍能继续存在。</p>
<p>为了降低程序的内存空间占用，Cocoa 在程序开始处理事件之前创建一个自动释放池，并在事件处理结束后销毁该自动释放池，这样可以使积累的临时对象的数量保持在最低程度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 当使用自动释放对象时，前面的方法可以重写如下：</div><div class="line"></div><div class="line">- (void) doStuff</div><div class="line">&#123;</div><div class="line">    // flonkArray is an instance variable</div><div class="line">    flonkArray = [NSMutableArray arrayWithCapacity: 17];    // count: 1, autoreleased</div><div class="line">    [flonkArray retain];    // count: 2, 1 autorelease</div><div class="line">&#125;   // doStuff</div><div class="line"></div><div class="line">- (void) dealloc</div><div class="line">&#123;</div><div class="line">    [flonkArray release];   // count: 0</div><div class="line">    [super dealloc];</div><div class="line">&#125;   // dealloc</div></pre></td></tr></table></figure>
<p>清理自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int i;</div><div class="line">for (i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">    id object = [someArray objectAtIndex: i];</div><div class="line">    NSString *desc = [object description];</div><div class="line">    // and do something with the description</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 上面这段代码执行一个循环，在大量的迭代中每次都会生成一个（或2个，10个）自动释放对象。请记住，自动释放池的销毁事件是完全确定的，它在循环执行的过程中不会被销毁。这个循环创建了100万个 description 字符串对象，所有这些对象都被放进当前的自动释放池中，因此就产生了100万个闲置的字符串，这100万个字符串对象一直存在，当自动释放池销毁时才最终获得释放。解决这类问题的方法是在循环中创建自己的释放池，每执行1000次左右，销毁当前自动释放池并创建一个新的自动释放池。代码如下 */</div><div class="line"></div><div class="line">NSAutoreleasePool *pool;</div><div class="line">pool = [[NSAutoreleasePool alloc] init];</div><div class="line">int i;</div><div class="line">for (i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">    id object = [someArray objectAtIndex: i];</div><div class="line">    NSString *desc = [object description];</div><div class="line">    // and do something with the description</div><div class="line">    if (i % 1000 == 0) &#123;</div><div class="line">        [pool release];</div><div class="line">        pool = [[NSAutoreleasePool alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[pool release];</div><div class="line"></div><div class="line">/* 自动释放池以栈的形式实现：当你创建一个新的自动释放池时，它将被添加到栈顶，接收 autorelease 消息的对象将被放入最顶端的自动释放池中。如果将一个对象放入一个自动释放池中，然后创建一个新的自动释放池再销毁该新建的自动释放池，则这个自动释放对象仍将存在，因为容纳该对象的自动释放池仍然存在。 */</div></pre></td></tr></table></figure>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Objective-C 2.0 引入了自动内存管理机制</p>
<blockquote>
<p>“-fobjc-gc” 选项能使代码既支持垃圾回收机制又支持对象的保留和释放。</p>
</blockquote>
<p>启用垃圾回收以后，通常的内存管理命令全都变成了空操作指令，不执行任何操作。</p>
<p>Objective-C 的垃圾回收是一种继承性的垃圾回收器。与那些存在了一段时间的对象相比，新创建的对象更可能被当成垃圾。如果在一个实例变量中指向某个对象，一定要在某个时候使该实例变量赋值为 nil，以取消对该对象的引用并使垃圾回收器知道该对象可以被清理。</p>
<h1 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h1><h2 id="分配对象"><a href="#分配对象" class="headerlink" title="分配对象"></a>分配对象</h2><p>分配（allocation）对象，从操作系统中获得一块内存并将其指定为存放对象的实例变量的位置。alloc 方法将分配的内存初始化为0。所有的 BOOL 类型变量初始化为 NO，int 类型变量初始化为0，float 类型变量初始化为0.0，指针被初始化为 nil。</p>
<h2 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h2><p>初始化（initialization）从操作系统获取一块内存，准备用于存储对象。init 方法几乎总是返回他们正在初始化的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Car *car = [[Car alloc] init]; // 不能将分配及初始化分开写，避免初始化方法返回的对象与分配的对象不同</div></pre></td></tr></table></figure>
<h3 id="编写初始化方法"><a href="#编写初始化方法" class="headerlink" title="编写初始化方法"></a>编写初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (id) init</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        enging = [Engine new];</div><div class="line"></div><div class="line">        tires[0] = [Tire new];</div><div class="line">        tires[1] = [Tire new];</div><div class="line">        tires[2] = [Tire new];</div><div class="line">        tires[3] = [Tire new];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return (self);</div><div class="line">&#125;   // init</div></pre></td></tr></table></figure>
<h3 id="指定初始化函数"><a href="#指定初始化函数" class="headerlink" title="指定初始化函数"></a>指定初始化函数</h3><h3 id="初始化函数规则"><a href="#初始化函数规则" class="headerlink" title="初始化函数规则"></a>初始化函数规则</h3><ul>
<li><p>不需要为你自己的类创建初始化函数方法。如果不需要设置任何状态，或者只需要 alloc 方法将内存清零的默认行为，则不需要担心init。</p>
</li>
<li><p>如果构造了一个初始化函数，则一定要在你自己的指定初始化函数中调用超类的指定初始化函数。</p>
</li>
<li><p>如果初始化函数不止一个，则要选择一个作为指定初始化函数。被选定的方法应该调用超类的指定初始化函数。</p>
</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Objective-C 2.0 中引入了特性（property），它组合了新的预编译指令和新的属性访问器语法。</p>
<h2 id="修改特性值"><a href="#修改特性值" class="headerlink" title="修改特性值"></a>修改特性值</h2><h2 id="简化接口"><a href="#简化接口" class="headerlink" title="简化接口"></a>简化接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;Tire.h&quot;</div><div class="line"></div><div class="line">@interface AllWeatherRadial : Tire &#123;</div><div class="line">    float rainHandling;</div><div class="line">    float snowHandling;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@property float rainHandling;</div><div class="line">@property float snowHandling;</div><div class="line"></div><div class="line">@end    // AllWeatherRadial</div></pre></td></tr></table></figure>
<p>@property 预编译指令自动声明属性的 setter 和 getter方法</p>
<h3 id="简化实现"><a href="#简化实现" class="headerlink" title="简化实现"></a>简化实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;AllWeatherRadial.h&quot;</div><div class="line"></div><div class="line">#implementtation AllWeatherRadial</div><div class="line"></div><div class="line">@synthesize rainHandling;</div><div class="line">@synthesize snowHandling;</div><div class="line"></div><div class="line">- (id) initWithPressure: (float) p treadDepth: (float) td</div><div class="line">&#123;</div><div class="line">    if (self = [super initWithPressure: p treadDepth: td]) &#123;</div><div class="line">        rainHandling = 23.7;</div><div class="line">        snowHandling = 42.5;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return (self);</div><div class="line">&#125;   // initWithPressure: treadDepth</div><div class="line"></div><div class="line">- (NSString *) description</div><div class="line">&#123;</div><div class="line">    NSString *desc;</div><div class="line">    desc = [[NSString alloc] initWithFormat: @&quot;AllWeatherRadial: %.1f / %.1f / %.1f / %.1f&quot;, [self pressure], [self treadDepth], [self rainHandling], [self snowHandling]];</div><div class="line"></div><div class="line">    return (desc);</div><div class="line">&#125;   // description</div><div class="line"></div><div class="line">@end    // AllWeatherRadial</div></pre></td></tr></table></figure>
<p>@synthesize 表示：创建该属性的访问器</p>
<h3 id="点表达式"><a href="#点表达式" class="headerlink" title="点表达式"></a>点表达式</h3><p>点表达式出现在等号左边，该属性名称的 setter 方法将被调用，如果点表达式出现在对象变量的右边，则该属性名称的 getter 方法将被调用。</p>
<h2 id="特性扩展"><a href="#特性扩展" class="headerlink" title="特性扩展"></a>特性扩展</h2><h3 id="名称的使用"><a href="#名称的使用" class="headerlink" title="名称的使用"></a>名称的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@synthesize name = appellcation</div></pre></td></tr></table></figure>
<h3 id="只读特性"><a href="#只读特性" class="headerlink" title="只读特性"></a>只读特性</h3><h1 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h1><h2 id="创建类别（category）"><a href="#创建类别（category）" class="headerlink" title="创建类别（category）"></a>创建类别（category）</h2><h3 id="声明类别"><a href="#声明类别" class="headerlink" title="声明类别"></a>声明类别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* 类别的声明格式与类的声明格式相似，类别名称必须唯一 */</div><div class="line">@interface NSString (NumberConvenience)</div><div class="line"></div><div class="line">- (NSNumber) lengthAsNumber;</div><div class="line"></div><div class="line">@end    // NumberConvenience</div></pre></td></tr></table></figure>
<p>类别不能添加新的实例变量，因此类别的声明中没有实例变量部分。</p>
<h3 id="实现类别"><a href="#实现类别" class="headerlink" title="实现类别"></a>实现类别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation NSString (NumbreConvenience)</div><div class="line"></div><div class="line">- (NSNumber *) lengthAsNumber</div><div class="line">&#123;</div><div class="line">    unsigned int length = [self length];</div><div class="line"></div><div class="line">    return ([NSNumber numberWithUnsignedInt: length]);</div><div class="line">&#125;   // lengthAsNumber</div><div class="line"></div><div class="line">@end    // NumberConvenience</div></pre></td></tr></table></figure>
<h3 id="类别的局限性"><a href="#类别的局限性" class="headerlink" title="类别的局限性"></a>类别的局限性</h3><ul>
<li><p>无法向类中添加新的实例变量。类别没有位置容纳实例变量。</p>
</li>
<li><p>名称冲突，即类别中的方法与现有的方法重名。当发生名称冲突时，类别具有更高的优先级，类别方法将取代初始方法，从而无法再使用初始方法。可加特定前缀以避免冲突。</p>
</li>
</ul>
<blockquote>
<p>也有一些技术可以克服类别无法增加新实例变量的局限，例如：全局字典存储对象与你想要关联的额外变量之间的映射。但此时需考虑，类别是否完成当前任务的最佳选择。</p>
</blockquote>
<h3 id="类别的作用"><a href="#类别的作用" class="headerlink" title="类别的作用"></a>类别的作用</h3><ul>
<li><p>将类的实现分散到多个不同文件或多个不同框架中；</p>
</li>
<li><p>创建对私有方法的向前引用；</p>
</li>
<li><p>向对象添加非正式协议（informal protocol）。</p>
</li>
</ul>
<h2 id="利用类别分散实现"><a href="#利用类别分散实现" class="headerlink" title="利用类别分散实现"></a>利用类别分散实现</h2><h2 id="使用类别创建向前引用"><a href="#使用类别创建向前引用" class="headerlink" title="使用类别创建向前引用"></a>使用类别创建向前引用</h2><p>如果能够先定义一个方法，然后再使用它，编译器将会找到你的方法定义，因而不产生警告。如果不方便这么做，或者你使用了另一个类尚未发布的方法，那么就需要采取其他措施。</p>
<p>通过在类别中声明该方法，编译器将不会产生警告。</p>
<h2 id="非正式协议和委托类别"><a href="#非正式协议和委托类别" class="headerlink" title="非正式协议和委托类别"></a>非正式协议和委托类别</h2><p>委托强调类别的一种应用：被发送给委托对象的方法可以声明为一个 NSObject 的类别。</p>
<blockquote>
<p>像这样创建 NSObject 的类别，任何类的对象都可以作为委托对象使用。</p>
</blockquote>
<p>非正式协议是 NSObject 的一个类别，它可以列出对象能够响应的方法。非正式协议用于实现委托。</p>
<p>选择器：@selector，可以在代码中指定特定的 Objective-C 消息。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="正式协议"><a href="#正式协议" class="headerlink" title="正式协议"></a>正式协议</h2><p>与非正式协议一样，正式协议也是一个命名的方法列表。但与非正式协议不同的是，正式协议要求显式的采用协议。采用协议的方法是在类的 @interface 声明中列出协议的名称。此时，你的类遵守该协议，并应该实现该协议的所有方法，否则，编译器会生成警告。Objective-C 2.0增加了一些良好的特性，以便更好使用协议。</p>
<blockquote>
<p>正式协议类似 Java 接口</p>
</blockquote>
<h3 id="声明协议"><a href="#声明协议" class="headerlink" title="声明协议"></a>声明协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 声明正式协议</div><div class="line">@protocol NSCopying</div><div class="line"></div><div class="line">- (id) copyWithZone: (NSZone *) zone;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li><p>@protocol 告诉编译器，这是一个正式协议。</p>
</li>
<li><p>协议名称必须唯一。</p>
</li>
<li><p>方法声明列表中的方法，在协议的每个采用者中都必须被实现。</p>
</li>
<li><p>使用协议不可引入新的实例变量。</p>
</li>
</ul>
<h3 id="采用协议"><a href="#采用协议" class="headerlink" title="采用协议"></a>采用协议</h3><p>要采用某个协议，必须在类声明中列出该协议的名称，并用尖括号括起。若存在多个协议，逗号隔开（顺序无关）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Car 采用协议 NSCopying 及 NSCoding</div><div class="line">@interface Car : NSObject &lt;NSCopying, NSCoding&gt;</div><div class="line">&#123;</div><div class="line">    // instance variables</div><div class="line">&#125;</div><div class="line"></div><div class="line">// methods</div><div class="line"></div><div class="line">@end    // Car</div></pre></td></tr></table></figure>
<h3 id="实现协议"><a href="#实现协议" class="headerlink" title="实现协议"></a>实现协议</h3><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><blockquote>
<p>浅层复制（Shallow Copy）、深层复制（Deep Copy）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 深层复制</div><div class="line">- (id) copyWithZone: (NSZone *) zone</div><div class="line">&#123;</div><div class="line">    Tire * tireCopy;</div><div class="line">    tireCopy = [[[self class] allocWithZone: zone] initWithPressure: pressure treadDepth: treadDepth];</div><div class="line"></div><div class="line">    return (tireCopy);</div><div class="line">&#125;   // copyWithZone</div></pre></td></tr></table></figure>
<blockquote>
<p>C 风格指针运算符直接访问实例变量<code>tireCopy -&gt; pressure = pressure; tireCopy -&gt; treadDepth = treadDepth;</code>。一般，设置属性不涉及额外工作时，尽量使用init方法和访问器方法。</p>
</blockquote>
<h2 id="Objective-C-2-0-新特性"><a href="#Objective-C-2-0-新特性" class="headerlink" title="Objective-C 2.0 新特性"></a>Objective-C 2.0 新特性</h2><ul>
<li><p>新增协议修饰符：@optional（方法可选实现）、@required（方法必须实现，默认属性）。</p>
</li>
<li><p>非正式协议在 Objective-C 2.0 之后，主键被带有 @optional 方法的正式协议代替。</p>
</li>
</ul>
<h1 id="AppKit-简介"><a href="#AppKit-简介" class="headerlink" title="AppKit 简介"></a>AppKit 简介</h1><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><blockquote>
<p>拖动连接的路径是从需要知道某些内容的对象到该对象需要了解的对象。类似 AppController 需要知道将哪个 NSTextField 用于用户输入，因此拖动方向从 AppController 到文本域。按钮需要知道告诉哪个对象，按钮被 click 了，此时需要从按钮拖到AppController。</p>
</blockquote>
<h1 id="文件加载与保存"><a href="#文件加载与保存" class="headerlink" title="文件加载与保存"></a>文件加载与保存</h1><p>标准 C 函数库提供了函数调用来创建、读取和写入文件，例如 open()、read()、write()、fopen() 和 fread()等。Cocoa 提供了 Core Data。另外 Cocoa 提供了两个通用的文件处理类：属性列表和对象编码。</p>
<h2 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h2><p>属性列表对象，常简写为 plist。属性列表类包括 NSArray、NSDictionary、NSString、NSNumber、NSDate、NSData，以及他们的变体（如果变体存在）。</p>
<h3 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h3><h3 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// NSData 对象保存一个普通的 C 字符串（一个字节序列），然后输出数据</div><div class="line">const char *string = &quot;Hi there, this is a C string!&quot;;</div><div class="line">// length: strlen(string) + 1 用于包含 C 字符串所需的尾部的零字节。</div><div class="line">NSData *data = [NSData dataWithBytes: string length: strlen(string) + 1];</div><div class="line">NSLog(@&quot;data is %@&quot;, data);</div><div class="line"></div><div class="line">//输出结果：`data is &lt;48692074 68657265 2c207468 69732069 73206120 43207374 72696e67 2100&gt;`</div><div class="line">// 包含末尾00的零字节数据，可以使用 %s 格式输出字符串</div><div class="line">NSLog(@&quot;%d byte string is &apos;%s&apos;&quot;, [data length], [data bytes]);</div><div class="line"></div><div class="line">//输出结果：`30 byte string is &apos;Hi there, this is a C string!&apos;`</div></pre></td></tr></table></figure>
<p>NSMutableData</p>
<h3 id="写入和读取属性列表"><a href="#写入和读取属性列表" class="headerlink" title="写入和读取属性列表"></a>写入和读取属性列表</h3><blockquote>
<p>在操作系统中，有许多属性列表文件和系统配置文件，如主目录 Library/Preference 下的所有首选项文件和 /System/Library/LaunchDaemons 下的系统配置文件。有些属性列表文件（特别是首选项文件）是以二进制格式存储的。通过使用 plutil 命令：plutil -convert xml1 filename.plist，可以将这些文件转换成可读形式。</p>
</blockquote>
<h2 id="编码对象"><a href="#编码对象" class="headerlink" title="编码对象"></a>编码对象</h2><p>采用 NSCoding 协议和实现方法来编码和解码对象：将大量对象转换成 NSData 类，保存到磁盘中，并在以后读取它，通过 NSData 类，重新创建对象。</p>
<h1 id="键-值编码"><a href="#键-值编码" class="headerlink" title="键/值编码"></a>键/值编码</h1><p>键/值编码（KVC）是一种间接更改对象状态的方式，其实现方法是使用字符串描述要更改的对象状态部分。Cocoa 的一些特性，如 Core Data 或 Cocoa Bindings 在基础机制中包含了 KVC。</p>
<h2 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h2><h2 id="KVC-简介"><a href="#KVC-简介" class="headerlink" title="KVC 简介"></a>KVC 简介</h2><p>键/值编码中的基本调用包括 -valueForKey: 和 -setValue:forKey:。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[car setValue: @&quot;Haroid&quot; forKey: @&quot;name&quot;];</div><div class="line">NSString *name = [car valueForKey: @&quot;name&quot;];</div><div class="line">NSLog(@&quot;%@&quot;, name);</div></pre></td></tr></table></figure>
<p>-valueForKey: 首先查找以键 -key 或 -isKey 命名的 getter 方法，对于这类调用 valueForKey: 查找 -name。如果不存在 getter 方法，它将在对象内部查找名为 _key 或 key 的实例变量，如果没有通过 @synthesize 提供存取方法，valueForKey 将会查找实例变量 _name 和 name。</p>
<ul>
<li><p>-valueForKey 在 Objective-C 运行时使用元数据打开对象并进入其中查找需要的信息，在 C 或 C++ 中不能执行这种操作。通过 KVC ，可以获取不存在 getter 方法的对象值，无需通过对象指针直接访问实例变量。</p>
</li>
<li><p>对于 KVC，Cocoa 自动放入和取出标量值。仅 KVC 具有这种自动包装功能。</p>
</li>
</ul>
<p>-setValue:forKey: 工作方法同 -valueForKey: 类似，首先查找名称的 setter 方法，如果不存在 setter 方法，它将再类中查找 key 或 _key 的实例变量，然后为其赋值。</p>
<blockquote>
<p>编译器和苹果公司都以下划线开头的形式保存实例变量名称，如果你尝试在其他地方使用下划线，可能会出现严重的错误。这条规则实际上不是强制的，但如果不遵守它，可能会遇到某些风险。</p>
</blockquote>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>除了通过键设置值外，键/值编码还支持指定键路径，你可以遵循一定关系来指定该路径。路径可以指定以圆点分隔不同属性名称。例如：“engine.horsepower”。</p>
<h2 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h2><p>关于 KVC 非常棒的一点是，如果向 NSArray 请求一个键值，它实际上会查询数组中的每个对象来查找这个键值，然后将查询结果打包到另一个数组中并返回给你。这种方法也适用于通过键路径访问的对象内部的数组。</p>
<p>在 KVC 中，通常认为嵌入到其他对象中的 NSArray 具有一对多的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSArray *pressures = [car valueForKeyPath: @&quot;tires.pressure&quot;];</div><div class="line"></div><div class="line">// 不能在键路径中为这些数组添加索引，例如，“tires[0].pressure” 是错误的。</div></pre></td></tr></table></figure>
<p>键路径不仅能引用对象值，还可以引用一些运算符来进行一些计算，例如获取一组值的平均值或返回这组值中的最小值和最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSNumber *count;</div><div class="line">// 计算汽车的数量，键路径 “cars.@count” 拆开，cars用于获取cars属性，它是 garage 的 NSArray 类型的值。@count 用于通知 KVC 机制计算键路径左侧的结果。</div><div class="line">count = [garage valueForKeyPath: @&quot;cars.@count&quot;];</div><div class="line"></div><div class="line">NSNumber *sum;</div><div class="line">// 计算某些特定值的总和，例如，车队行驶的总英里数</div><div class="line">sum = [garage valueForKeyPath: @&quot;cars.@sum.mileage&quot;];</div><div class="line"></div><div class="line">NSNumber *avgMileage;</div><div class="line">// 计算平均每辆汽车行驶的距离</div><div class="line">avgMileage = [garage valueForKeyPath: @&quot;cars.@avg.mileage&quot;];</div><div class="line"></div><div class="line">// @min、@max</div><div class="line">NSNumber *min, *max;</div><div class="line">min = [garage valueForKeyPath: @&quot;cars.@min.mileage&quot;];</div><div class="line">max = [garage valueForKeyPath: @&quot;cars.@max.mileage&quot;];</div></pre></td></tr></table></figure>
<blockquote>
<p>KVC 能非常轻松的处理集合。但是 KVC 需要通过解析字符串来计算你所需要的答案，因此速度比较慢；编译器无法对它进行错误检查，当你使用错误的键路径时，会出现运行时错误。</p>
</blockquote>
<h2 id="nil值处理"><a href="#nil值处理" class="headerlink" title="nil值处理"></a>nil值处理</h2><h2 id="处理未定义的键"><a href="#处理未定义的键" class="headerlink" title="处理未定义的键"></a>处理未定义的键</h2><p>如果 KVC 机制无法找到键路径的处理方式，默认实现会取消操作。但我们可以通过更改默认行为来处理这种情况。valueForUndefinedKey: 方法或 setValue:forUndefinedKey: 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface Garage : NSObject &#123;</div><div class="line">    NSString *name;</div><div class="line">    NSMutableArray *cars;</div><div class="line">    NSMutableDictionary *stuff;</div><div class="line">&#125;</div><div class="line">// ... 其他代码</div><div class="line">@end    // Garage</div><div class="line"></div><div class="line">// 在实现中添加 valueForUndefinedKey: 及 setValue:forUndefinedKey: 方法</div><div class="line">- (void) setValue: (id) value forUndefinedKey: (NSString *) key &#123;</div><div class="line">    if (stuff == nil) &#123;</div><div class="line">        stuff = [[NSMutableDictionary alloc] init];</div><div class="line">    &#125;</div><div class="line">    [stuff setValue: value forKey: key];</div><div class="line">&#125;   // setValueForUndefinedKey</div><div class="line"></div><div class="line">- (id) valueForUndefinedKey: (NSString *) key &#123;</div><div class="line">    id value = [stuff valueForKey: key];</div><div class="line">    return (value);</div><div class="line">&#125;   // valueForUndefinedKey</div></pre></td></tr></table></figure>
<h1 id="NSPredicate"><a href="#NSPredicate" class="headerlink" title="NSPredicate"></a>NSPredicate</h1><p>Cocoa 用 NSPredicate 类描述查询方式</p>
<h2 id="创建谓词"><a href="#创建谓词" class="headerlink" title="创建谓词"></a>创建谓词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 创建谓词，</div><div class="line">NSPredicate *predicate;</div><div class="line">predicate = [NSPredicate predicateWithFormat: @&quot;name == &apos;Herbie&apos;&quot;];</div><div class="line"></div><div class="line">// 计算谓词</div><div class="line">BOOL match = [predicate evaluateWithObject: car];</div><div class="line">NSLog(@&quot;%s&quot;, (match) ? &quot;YES&quot; : &quot;NO&quot;);</div></pre></td></tr></table></figure>
<h2 id="燃料过滤器"><a href="#燃料过滤器" class="headerlink" title="燃料过滤器"></a>燃料过滤器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSArray *results;</div><div class="line">// 返回符合条件的car</div><div class="line">results = [cars filteredArrayUsingPredicate: predicate];</div><div class="line">NSLog(@&quot;%@&quot;, results);</div></pre></td></tr></table></figure>
<p>使用谓词确实很便捷，但它的运行速度不会比你自己编写全部代码快。因为它无法避免在所有汽车之间使用循环和对每辆汽车进行某些操作。一般来说，这种循环不会带来很大的性能影响，因为当今的计算机运行速度非常快。可以继续编写尽可能简易的代码。如果你遇到速度问题，可以使用苹果公司的工具（如 Shark 或 Instruments）测试程序性能。</p>
<h2 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符"></a>格式说明符</h2><p>可以在谓词中使用格式说明符 %d、%f、%@（指定值）或 %K（指定键路径）。或者直接将变量名放入字符串 $NAME 来指定值。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="比较和逻辑运算符"><a href="#比较和逻辑运算符" class="headerlink" title="比较和逻辑运算符"></a>比较和逻辑运算符</h3><p>谓词字符串语法支持 C 语言中的一些常用运算符。例如： ==、=、&gt;、&gt;= 或 =&gt;、&lt;、&lt;= 或 =&lt;、!= 或 &lt;&gt;、括号表达式、AND、OR、NOT 逻辑运算符或C样式的等效表达式 &amp;&amp;、|| 和 !。</p>
<p>谓词字符串中运算符不区分大小写。</p>
<h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">predicate = [NSPredicate predicateWithFormat: @&quot;engine.horsepower BETWEEN &#123;50, 200&#125;&quot;];</div><div class="line"></div><div class="line">predicate = [NSPredicate predicateWithFormat: @&quot;name IN &#123;&apos;Herbie&apos;, &apos;Snugs&apos;, &apos;Badger&apos;, &apos;Flap&apos;&#125;&quot;];</div></pre></td></tr></table></figure>
<h2 id="SELF"><a href="#SELF" class="headerlink" title="SELF"></a>SELF</h2><p>SELF 可以引用用于谓词计算的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">predicate = [NSPredicate predicateWithFormat: @&quot;SELF.name IN &#123;&apos;Herbie&apos;, &apos;Snugs&apos;, &apos;Badger&apos;, &apos;Flap&apos;&#125;&quot;];</div></pre></td></tr></table></figure>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>BEGINSWITH：某个字符串是否以另外一个字符串开头；ENDSWITH：某个字符串是否以另外一个字符串结尾；CONTAINS：某个字符串是否在另一个字符串内部。</p>
<p>以上运算符可增加 [c] 不区分大小写、[d] 不区分发音符号、[cd] 既不区分大小写又不区分发音符号 等修饰符</p>
<h2 id="LIKE-运算符"><a href="#LIKE-运算符" class="headerlink" title="LIKE 运算符"></a>LIKE 运算符</h2><h2 id="MATCHES-正则运算符"><a href="#MATCHES-正则运算符" class="headerlink" title="MATCHES 正则运算符"></a>MATCHES 正则运算符</h2><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li><p><em>类</em> 是一种结构，它表示对象的类型。对象引用类来获取和自身相关的各种信息。Objective-C 编程风格建议开发人员使用首字母大写的类名。</p>
</li>
<li><p><em>对象</em> 是一种结构，它包含值和指向其类的隐藏指针。引用对象的 Objective-C 变量通常不需要首字母大写。</p>
</li>
<li><p><em>消息</em> 是对象可以执行的操作，用于通知对象去做什么。在 [shape draw] 代码中，通过向 shape 对象发送 draw 消息来通知对象绘制自身。对象接收消息后，将查询对应的类，以便查找正确的代码来运行。</p>
</li>
<li><p><em>方法</em> 是为响应消息而运行的代码。根据对象的类，消息（例如 draw）可以调用不同的方法。</p>
</li>
<li><p><em>方法调度程序</em> 是 Objective-C 使用的一种机制，用于推测执行什么方法以响应某个特定得消息。</p>
</li>
<li><p><em>接口</em> 是对象的类应该提供的特性的描述。接口不提供具体的实现细节。</p>
</li>
<li><p><em>实现</em> 是使接口正常工作的代码。</p>
</li>
<li><p><em>实例化（instantiation）</em> 根据类信息进行内存分配和初始化，创建一个新的对象实例。</p>
</li>
<li><p><em>继承</em> 定义一个具有父类所有功能的新类，它继承了父类的这些功能。</p>
</li>
<li><p><em>复合</em> 在复合中，对象可以引用其他对象。例如汽车对象可以引用轮胎对象。</p>
</li>
<li><p><em>重构</em>。</p>
</li>
<li><p><em>超类（superclass）</em>、<em>父类（parentclass）</em>、<em>子类（subclass）</em>、<em>子类（childclass）</em>。</p>
</li>
<li><p><em>委托（delegate）</em> 是一种对象，另一个类的对象会要求委托对象执行它的某些操作。</p>
</li>
<li><p><em>非正式协议</em>。</p>
</li>
<li><p><em>正式协议（formal protocol）</em>。</p>
</li>
<li><p><em>.xib 文件</em> .xib 文件是 XML 格式的 nib 文件。在编译时，.xib文件将编译为nib格式。</p>
</li>
<li><p><em>编码（序列化）</em>、<em>解码（反序列化）</em>。</p>
</li>
</ul>
<blockquote>
<ul>
<li>书名《Learn Objective-C on the Mac》Objective-C 基础教程</li>
<li>高朝勤 杨越 刘霞 等译，人民邮电出版社</li>
<li><p>2009年8月第一版</p>
</li>
<li><p><strong>这本书写得或者是翻译得很差。</strong></p>
</li>
</ul>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward.jpg" alt="Arcticfox WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward.jpg" alt="Arcticfox Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Arcticfox
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://blog.longgen.me/2014/03/23/47427/" title="Objective-C 学习">http://blog.longgen.me/2014/03/23/47427/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/03/23/6817/" rel="next" title="本博客 Markdown 语法测试">
                <i class="fa fa-chevron-left"></i> 本博客 Markdown 语法测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/03/25/32281/" rel="prev" title="Android 下 OpenGL ES">
                Android 下 OpenGL ES <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/fox.jpg"
               alt="Arcticfox" />
          <p class="site-author-name" itemprop="name">Arcticfox</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">53</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fjarcticfox" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/onelark" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预备知识"><span class="nav-number">1.1.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#历史背景"><span class="nav-number">1.2.</span> <span class="nav-text">历史背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内容简介"><span class="nav-number">1.3.</span> <span class="nav-text">内容简介</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对-C-的扩展"><span class="nav-number">2.</span> <span class="nav-text">对 C 的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hello-World"><span class="nav-number">2.1.</span> <span class="nav-text">Hello World</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#import"><span class="nav-number">2.1.1.</span> <span class="nav-text">#import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSLog-和-“字符串”"><span class="nav-number">2.1.2.</span> <span class="nav-text">NSLog() 和 @“字符串”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔类型"><span class="nav-number">2.2.</span> <span class="nav-text">布尔类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程基础知识"><span class="nav-number">3.</span> <span class="nav-text">面向对象编程基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#间接（indirection）"><span class="nav-number">3.1.</span> <span class="nav-text">间接（indirection）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量与间接"><span class="nav-number">3.1.1.</span> <span class="nav-text">变量与间接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用文件名的间接"><span class="nav-number">3.1.2.</span> <span class="nav-text">使用文件名的间接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在面向对象的编程中使用间接"><span class="nav-number">3.2.</span> <span class="nav-text">在面向对象的编程中使用间接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承"><span class="nav-number">4.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为何使用继承"><span class="nav-number">4.1.</span> <span class="nav-text">为何使用继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承语法"><span class="nav-number">4.2.</span> <span class="nav-text">继承语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的工作机制"><span class="nav-number">4.3.</span> <span class="nav-text">继承的工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调度"><span class="nav-number">4.3.1.</span> <span class="nav-text">方法调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例变量"><span class="nav-number">4.3.2.</span> <span class="nav-text">实例变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写方法"><span class="nav-number">4.4.</span> <span class="nav-text">重写方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复合"><span class="nav-number">5.</span> <span class="nav-text">复合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是复合"><span class="nav-number">5.1.</span> <span class="nav-text">什么是复合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存取方法"><span class="nav-number">5.2.</span> <span class="nav-text">存取方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合（has-a）与继承（is-a）的选择"><span class="nav-number">5.3.</span> <span class="nav-text">复合（has a）与继承（is a）的选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源文件组织"><span class="nav-number">6.</span> <span class="nav-text">源文件组织</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入了解-Xcode"><span class="nav-number">7.</span> <span class="nav-text">深入了解 Xcode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Foundation-Kit"><span class="nav-number">8.</span> <span class="nav-text">Foundation Kit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">8.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSRange"><span class="nav-number">8.1.1.</span> <span class="nav-text">NSRange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几何数据类型"><span class="nav-number">8.1.2.</span> <span class="nav-text">几何数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变字符串-NSString"><span class="nav-number">8.2.</span> <span class="nav-text">不可变字符串 NSString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合家族"><span class="nav-number">8.3.</span> <span class="nav-text">集合家族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变数组-NSArray"><span class="nav-number">8.3.1.</span> <span class="nav-text">不可变数组 NSArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变数组-NSMutableArray"><span class="nav-number">8.3.2.</span> <span class="nav-text">可变数组 NSMutableArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举"><span class="nav-number">8.3.3.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速枚举"><span class="nav-number">8.3.4.</span> <span class="nav-text">快速枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变字典-NSDictionary-与-可变字典-NSMutableDictionary"><span class="nav-number">8.3.5.</span> <span class="nav-text">不可变字典 NSDictionary 与 可变字典 NSMutableDictionary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用，但不要扩展"><span class="nav-number">8.3.6.</span> <span class="nav-text">使用，但不要扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值类型"><span class="nav-number">8.4.</span> <span class="nav-text">数值类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSNumber"><span class="nav-number">8.4.1.</span> <span class="nav-text">NSNumber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSValue"><span class="nav-number">8.4.2.</span> <span class="nav-text">NSValue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSNull"><span class="nav-number">8.4.3.</span> <span class="nav-text">NSNull</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">9.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象生命周期"><span class="nav-number">9.1.</span> <span class="nav-text">对象生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数（reference-counting，也叫保留计数）"><span class="nav-number">9.1.1.</span> <span class="nav-text">引用计数（reference counting，也叫保留计数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象所有权（object-ownership）"><span class="nav-number">9.1.2.</span> <span class="nav-text">对象所有权（object ownership）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问方法中的保留和释放"><span class="nav-number">9.1.3.</span> <span class="nav-text">访问方法中的保留和释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动释放"><span class="nav-number">9.2.</span> <span class="nav-text">自动释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有对象全部入池"><span class="nav-number">9.2.1.</span> <span class="nav-text">所有对象全部入池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动释放池的销毁时间"><span class="nav-number">9.2.2.</span> <span class="nav-text">自动释放池的销毁时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动释放池的工作过程"><span class="nav-number">9.2.3.</span> <span class="nav-text">自动释放池的工作过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cocoa-内存管理规则"><span class="nav-number">9.3.</span> <span class="nav-text">Cocoa 内存管理规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#临时对象"><span class="nav-number">9.3.1.</span> <span class="nav-text">临时对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥有对象"><span class="nav-number">9.3.2.</span> <span class="nav-text">拥有对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收"><span class="nav-number">9.3.3.</span> <span class="nav-text">垃圾回收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象初始化"><span class="nav-number">10.</span> <span class="nav-text">对象初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分配对象"><span class="nav-number">10.1.</span> <span class="nav-text">分配对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化对象"><span class="nav-number">10.2.</span> <span class="nav-text">初始化对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写初始化方法"><span class="nav-number">10.2.1.</span> <span class="nav-text">编写初始化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定初始化函数"><span class="nav-number">10.2.2.</span> <span class="nav-text">指定初始化函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化函数规则"><span class="nav-number">10.2.3.</span> <span class="nav-text">初始化函数规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特性"><span class="nav-number">11.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#修改特性值"><span class="nav-number">11.1.</span> <span class="nav-text">修改特性值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简化接口"><span class="nav-number">11.2.</span> <span class="nav-text">简化接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简化实现"><span class="nav-number">11.2.1.</span> <span class="nav-text">简化实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点表达式"><span class="nav-number">11.2.2.</span> <span class="nav-text">点表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性扩展"><span class="nav-number">11.3.</span> <span class="nav-text">特性扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#名称的使用"><span class="nav-number">11.3.1.</span> <span class="nav-text">名称的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只读特性"><span class="nav-number">11.3.2.</span> <span class="nav-text">只读特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类别"><span class="nav-number">12.</span> <span class="nav-text">类别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建类别（category）"><span class="nav-number">12.1.</span> <span class="nav-text">创建类别（category）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明类别"><span class="nav-number">12.1.1.</span> <span class="nav-text">声明类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现类别"><span class="nav-number">12.1.2.</span> <span class="nav-text">实现类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类别的局限性"><span class="nav-number">12.1.3.</span> <span class="nav-text">类别的局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类别的作用"><span class="nav-number">12.1.4.</span> <span class="nav-text">类别的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用类别分散实现"><span class="nav-number">12.2.</span> <span class="nav-text">利用类别分散实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用类别创建向前引用"><span class="nav-number">12.3.</span> <span class="nav-text">使用类别创建向前引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非正式协议和委托类别"><span class="nav-number">12.4.</span> <span class="nav-text">非正式协议和委托类别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协议"><span class="nav-number">13.</span> <span class="nav-text">协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#正式协议"><span class="nav-number">13.1.</span> <span class="nav-text">正式协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明协议"><span class="nav-number">13.1.1.</span> <span class="nav-text">声明协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#采用协议"><span class="nav-number">13.1.2.</span> <span class="nav-text">采用协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现协议"><span class="nav-number">13.1.3.</span> <span class="nav-text">实现协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制"><span class="nav-number">13.2.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C-2-0-新特性"><span class="nav-number">13.3.</span> <span class="nav-text">Objective-C 2.0 新特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AppKit-简介"><span class="nav-number">14.</span> <span class="nav-text">AppKit 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构建项目"><span class="nav-number">14.1.</span> <span class="nav-text">构建项目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件加载与保存"><span class="nav-number">15.</span> <span class="nav-text">文件加载与保存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性列表"><span class="nav-number">15.1.</span> <span class="nav-text">属性列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSDate"><span class="nav-number">15.1.1.</span> <span class="nav-text">NSDate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSData"><span class="nav-number">15.1.2.</span> <span class="nav-text">NSData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入和读取属性列表"><span class="nav-number">15.1.3.</span> <span class="nav-text">写入和读取属性列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码对象"><span class="nav-number">15.2.</span> <span class="nav-text">编码对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#键-值编码"><span class="nav-number">16.</span> <span class="nav-text">键/值编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#入门项目"><span class="nav-number">16.1.</span> <span class="nav-text">入门项目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVC-简介"><span class="nav-number">16.2.</span> <span class="nav-text">KVC 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径"><span class="nav-number">16.3.</span> <span class="nav-text">路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整体操作"><span class="nav-number">16.4.</span> <span class="nav-text">整体操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nil值处理"><span class="nav-number">16.5.</span> <span class="nav-text">nil值处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理未定义的键"><span class="nav-number">16.6.</span> <span class="nav-text">处理未定义的键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NSPredicate"><span class="nav-number">17.</span> <span class="nav-text">NSPredicate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建谓词"><span class="nav-number">17.1.</span> <span class="nav-text">创建谓词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#燃料过滤器"><span class="nav-number">17.2.</span> <span class="nav-text">燃料过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式说明符"><span class="nav-number">17.3.</span> <span class="nav-text">格式说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">17.4.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#比较和逻辑运算符"><span class="nav-number">17.4.1.</span> <span class="nav-text">比较和逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组运算符"><span class="nav-number">17.4.2.</span> <span class="nav-text">数组运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SELF"><span class="nav-number">17.5.</span> <span class="nav-text">SELF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串运算符"><span class="nav-number">17.6.</span> <span class="nav-text">字符串运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LIKE-运算符"><span class="nav-number">17.7.</span> <span class="nav-text">LIKE 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MATCHES-正则运算符"><span class="nav-number">17.8.</span> <span class="nav-text">MATCHES 正则运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关术语"><span class="nav-number">17.9.</span> <span class="nav-text">相关术语</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arcticfox</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "ddb604bcb4fb4d259c017d8452b6d476",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("KkQwoIpV0sErnKDuj1de7svQ-gzGzoHsz", "Gqso4MtlbSkab8QQEp2cFX22");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
